!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/hibenouk/Desktop/todo-app/backend/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
AuthMiddleware	auth.go	/^func AuthMiddleware() func(next http.Handler) http.Handler {$/;"	f	package:main	typeref:typename:func(next http.Handler) http.Handler
CreateProjectDB	db.go	/^func CreateProjectDB(p Project) (*Project, error) {$/;"	f	package:main	typeref:typename:(*Project, error)
CreateSession	db.go	/^func CreateSession(session_key string, userID int) (error) {$/;"	f	package:main	typeref:typename:(error)
CreateTodoDB	db.go	/^func CreateTodoDB(t Todo, userID int) (*Todo, error) {$/;"	f	package:main	typeref:typename:(*Todo, error)
CreateUser	db.go	/^func CreateUser(username, password string) (*User, error) {$/;"	f	package:main	typeref:typename:(*User, error)
CreatedAt	db.go	/^	CreatedAt   time.Time `json:"createdAt"    db:"created_at"`$/;"	m	struct:main.Project	typeref:typename:time.Time
CreatedAt	db.go	/^	CreatedAt   time.Time `json:"createdAt"    db:"created_at"`$/;"	m	struct:main.Todo	typeref:typename:time.Time
CreatedAt	db.go	/^	CreatedAt  time.Time  `json:"createdAt"  db:"created_at"`$/;"	m	struct:main.User	typeref:typename:time.Time
DeleteProjectDB	db.go	/^func DeleteProjectDB(projectID string, id int) error {$/;"	f	package:main	typeref:typename:error
DeleteTodoDB	db.go	/^func DeleteTodoDB(todoID string, userID int) error {$/;"	f	package:main	typeref:typename:error
Description	db.go	/^	Description string    `json:"description"  db:"description"`$/;"	m	struct:main.Project	typeref:typename:string
Description	db.go	/^	Description string    `json:"description"  db:"description"`$/;"	m	struct:main.Todo	typeref:typename:string
GetCurrentUser	db.go	/^func GetCurrentUser(id int) (*User, error) {$/;"	f	package:main	typeref:typename:(*User, error)
GetProjectsDB	db.go	/^func GetProjectsDB(id int) ([]Project, error) {$/;"	f	package:main	typeref:typename:([]Project, error)
GetTodosByProjectDB	db.go	/^func GetTodosByProjectDB(projectID string, userID int) ([]Todo, error) {$/;"	f	package:main	typeref:typename:([]Todo, error)
GetUser	auth.go	/^func GetUser(w http.ResponseWriter, r *http.Request) {$/;"	f	package:main
GetUserByUsername	db.go	/^func GetUserByUsername(username string) (*User, error) {$/;"	f	package:main	typeref:typename:(*User, error)
GetUserFromSession	db.go	/^func GetUserFromSession(sessionToken string) (*User, error) {$/;"	f	package:main	typeref:typename:(*User, error)
HashPassword	auth.go	/^func HashPassword(password string) (string, error) {$/;"	f	package:main	typeref:typename:(string, error)
ID	db.go	/^	ID          string    `json:"id"           db:"id"`$/;"	m	struct:main.Project	typeref:typename:string
ID	db.go	/^	ID          string    `json:"id"           db:"id"`$/;"	m	struct:main.Todo	typeref:typename:string
ID	db.go	/^	ID         int        `json:"id"         db:"id"`$/;"	m	struct:main.User	typeref:typename:int
Login	auth.go	/^func Login(w http.ResponseWriter, r *http.Request) {$/;"	f	package:main
Logout	auth.go	/^func Logout(w http.ResponseWriter, r *http.Request) {$/;"	f	package:main
Name	db.go	/^	Name        string    `json:"name"         db:"name"`$/;"	m	struct:main.Project	typeref:typename:string
Password	auth.go	/^	Password string `json:"password"`$/;"	m	struct:main.UserLogin	typeref:typename:string
Password	db.go	/^	Password   string     `json:"password"   db:"password"`$/;"	m	struct:main.User	typeref:typename:string
Project	db.go	/^type Project struct {$/;"	s	package:main
ProjectID	db.go	/^	ProjectID   string    `json:"projectId"    db:"project_id"`$/;"	m	struct:main.Todo	typeref:typename:string
Session	auth.go	/^var Session map[string]User$/;"	v	package:main	typeref:typename:map[string]User
Status	db.go	/^	Status      string    `json:"status"       db:"status"`$/;"	m	struct:main.Todo	typeref:typename:string
Title	db.go	/^	Title       string    `json:"title"        db:"title"`$/;"	m	struct:main.Todo	typeref:typename:string
Todo	db.go	/^type Todo struct {$/;"	s	package:main
UpdateTodoDB	db.go	/^func UpdateTodoDB(todoID string, userID int, t Todo) (*Todo, error) {$/;"	f	package:main	typeref:typename:(*Todo, error)
UpdatedAt	db.go	/^	UpdatedAt   time.Time `json:"updatedAt"    db:"updated_at"`$/;"	m	struct:main.Project	typeref:typename:time.Time
UpdatedAt	db.go	/^	UpdatedAt   time.Time `json:"updatedAt"    db:"updated_at"`$/;"	m	struct:main.Todo	typeref:typename:time.Time
User	db.go	/^type User struct {$/;"	s	package:main
UserContextKey	auth.go	/^const UserContextKey contextKey = "user"$/;"	c	package:main	typeref:type:contextKey
UserID	db.go	/^	UserID      int       `json:"userId"       db:"user_id"`$/;"	m	struct:main.Project	typeref:typename:int
UserLogin	auth.go	/^type UserLogin struct {$/;"	s	package:main
Username	auth.go	/^	Username string `json:"username"`$/;"	m	struct:main.UserLogin	typeref:typename:string
Username	db.go	/^	Username   string     `json:"username"   db:"username"`$/;"	m	struct:main.User	typeref:typename:string
VerifyPassword	auth.go	/^func VerifyPassword(password, hash string) bool {$/;"	f	package:main	typeref:typename:bool
applySchema	main.go	/^func applySchema() error {$/;"	f	package:main	typeref:typename:error
contextKey	auth.go	/^type contextKey string$/;"	t	package:main	typeref:typename:string
createProject	handlers.go	/^func createProject(w http.ResponseWriter, r *http.Request) {$/;"	f	package:main
createTodo	handlers.go	/^func createTodo(w http.ResponseWriter, r *http.Request) {$/;"	f	package:main
created_at	schema.sql	/^    created_at DATETIME  DEFAULT CURRENT_TIMESTAMP$/;"	E	table:users
created_at	schema.sql	/^    created_at DATETIME  DEFAULT CURRENT_TIMESTAMP,$/;"	E	table:projects
created_at	schema.sql	/^    created_at DATETIME  DEFAULT CURRENT_TIMESTAMP,$/;"	E	table:todos
created_at	schema.sql	/^    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,$/;"	E	table:session
db	main.go	/^var db *sqlx.DB$/;"	v	package:main	typeref:typename:*sqlx.DB
deleteProject	handlers.go	/^func deleteProject(w http.ResponseWriter, r *http.Request) {$/;"	f	package:main
deleteTodo	handlers.go	/^func deleteTodo(w http.ResponseWriter, r *http.Request) {$/;"	f	package:main
description	schema.sql	/^    description TEXT,$/;"	E	table:projects
description	schema.sql	/^    description TEXT,$/;"	E	table:todos
ensure	main.go	/^func ensure() {$/;"	f	package:main
getProjects	handlers.go	/^func getProjects(w http.ResponseWriter, r *http.Request) {$/;"	f	package:main
getRandomKey	auth.go	/^func getRandomKey(size int) (string, error) {$/;"	f	package:main	typeref:typename:(string, error)
getTodosByProject	handlers.go	/^func getTodosByProject(w http.ResponseWriter, r *http.Request) {$/;"	f	package:main
getUserFromContext	auth.go	/^func getUserFromContext(ctx context.Context) *User {$/;"	f	package:main	typeref:typename:*User
getUserInfo	auth.go	/^func getUserInfo(session_key string) (*User, error) {$/;"	f	package:main	typeref:typename:(*User, error)
id	schema.sql	/^    id INTEGER PRIMARY KEY AUTOINCREMENT,$/;"	E	table:users
id	schema.sql	/^    id TEXT PRIMARY KEY,$/;"	E	table:projects
id	schema.sql	/^    id TEXT PRIMARY KEY,$/;"	E	table:todos
loadEnv	main.go	/^func loadEnv() {$/;"	f	package:main
main	auth.go	/^package main$/;"	p
main	db.go	/^package main$/;"	p
main	handlers.go	/^package main$/;"	p
main	main.go	/^func main() {$/;"	f	package:main
main	main.go	/^package main$/;"	p
main	routes.go	/^package main$/;"	p
name	schema.sql	/^    name TEXT NOT NULL,$/;"	E	table:projects
password	schema.sql	/^    password TEXT NOT NULL,$/;"	E	table:users
project_id	schema.sql	/^    project_id TEXT NOT NULL,$/;"	E	table:todos
projects	schema.sql	/^CREATE TABLE IF NOT EXISTS projects ($/;"	t
session	schema.sql	/^CREATE TABLE IF NOT EXISTS session ($/;"	t
session_key	schema.sql	/^    session_key TEXT PRIMARY KEY NOT NULL UNIQUE,$/;"	E	table:session
setupDB	main.go	/^func setupDB() {$/;"	f	package:main
setupRoutes	routes.go	/^func setupRoutes() http.Handler {$/;"	f	package:main	typeref:typename:http.Handler
staticFileServer	routes.go	/^func staticFileServer(r chi.Router, path string, root http.FileSystem) {$/;"	f	package:main
status	schema.sql	/^    status TEXT NOT NULL,$/;"	E	table:todos
title	schema.sql	/^    title TEXT NOT NULL,$/;"	E	table:todos
todos	schema.sql	/^CREATE TABLE IF NOT EXISTS todos ($/;"	t
updateTodo	handlers.go	/^func updateTodo(w http.ResponseWriter, r *http.Request) {$/;"	f	package:main
user_id	schema.sql	/^    user_id INTEGER NOT NULL,$/;"	E	table:projects
user_id	schema.sql	/^    user_id INTEGER NOT NULL,$/;"	E	table:session
username	schema.sql	/^    username TEXT NOT NULL UNIQUE,$/;"	E	table:users
users	schema.sql	/^CREATE TABLE IF NOT EXISTS users($/;"	t
